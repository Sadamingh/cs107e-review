<div align="center">
  <h1>
    Computer Systems from the Ground Up
  </h1>
</div>

My study note of the awesome course: [CS107E Winter 2020](http://cs107e.github.io/).

## Table of Contents

<!-- vim-markdown-toc GFM -->

* [Setup](#setup)
* [Week1: Introduction and Welcome](#week1-introduction-and-welcome)
  * [Raspberry Pi](#raspberry-pi)
  * [ARM processor and architecture](#arm-processor-and-architecture)
  * [Assignment 0](#assignment-0)
* [Week 2](#week-2)
* [Week 3](#week-3)
* [ARM Tips](#arm-tips)

<!-- vim-markdown-toc -->

## Setup

`source ./setup.sh`

## Week1: Introduction and Welcome

[List of electronic parts we will use in this course](https://cs107e.github.io/guides/bom/).

### Raspberry Pi

The raspberry model we are gonna use is [Raspberry Pi 1 Model A+](https://www.raspberrypi.org/products/raspberry-pi-1-model-a-plus/).

Must stick with this version otherwise the code might not work.

The CPU model of the Pi is [BCM2835](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md) (ARM11 series, ARMv6 architecture).

Check the manual here [BCM2835 Peripherals Specification](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf).

You need to know that this manual __has a lot of errors__, must read it with [BCM 2835 Datasheet Errata](https://elinux.org/BCM2835_datasheet_errata#p96).

NOTE: __The address in the manual `0x7E...` is the logic address, in the code we will change it to `0x20...`__.

Useful links for Pi:

- [Pinout](https://pinout.xyz/): GPIO Pinout guide

### ARM processor and architecture

First, we need to install the arm toolchain for our pi (compiler, assembler, linker, etc..) and the CP2012 driver. Check the [Installation Guide](http://cs107e.github.io/guides/install/).

After installation, we should have bunch of `arm-none-eabi` tools.

```bash
cs107e git:(master) ❯ whence -a -m 'arm-none-eabi*'
/usr/local/bin/arm-none-eabi-addr2line
/usr/local/bin/arm-none-eabi-ar
/usr/local/bin/arm-none-eabi-as
/usr/local/bin/arm-none-eabi-c++filt
/usr/local/bin/arm-none-eabi-cpp
/usr/local/bin/arm-none-eabi-elfedit
/usr/local/bin/arm-none-eabi-gcc
/usr/local/bin/arm-none-eabi-gcc-4.8.3
/usr/local/bin/arm-none-eabi-gcc-ar
/usr/local/bin/arm-none-eabi-gcc-nm
/usr/local/bin/arm-none-eabi-gcc-ranlib
/usr/local/bin/arm-none-eabi-gcov
/usr/local/bin/arm-none-eabi-gdb
/usr/local/bin/arm-none-eabi-gprof
/usr/local/bin/arm-none-eabi-ld
/usr/local/bin/arm-none-eabi-ld.bfd
/usr/local/bin/arm-none-eabi-nm
/usr/local/bin/arm-none-eabi-objcopy
/usr/local/bin/arm-none-eabi-objdump
/usr/local/bin/arm-none-eabi-ranlib
/usr/local/bin/arm-none-eabi-readelf
/usr/local/bin/arm-none-eabi-run
/usr/local/bin/arm-none-eabi-size
/usr/local/bin/arm-none-eabi-strings
/usr/local/bin/arm-none-eabi-strip
```

What is the meaning of `arm-none-eabi`? It turns out that:

> Unix cross compilers are loosely named using a convention of the form `arch[-vendor][-os]-abi`.

> The arch refers to the target architecture, which in our case is ARM. The vendor nominally refers to the
toolchain supplier. The os refers to the target operating system, if any, and is used to decide which libraries
(e.g. newlib, glibc, crt0, etc.) to link and which syscall conventions to employ. The abi specifies which
application binary interface convention is being employed, which ensures that binaries generated by different
tools can interoperate.

So `none` menas we are not targeting any operating system here, aka we are in "bare metal". And `eabi` means the ABI for the ARM architecture.

- [Intro to ARM assembly](http://www.toves.org/books/arm/)
- [VisUAL](https://salmanarif.bitbucket.io/visual/index.html): Visual ARM emulator

### Assignment 0

This is for the official students, I have nothing to do here.

## Week 2

- 所有的 ARM 指令都可以条件执行

ARM 立即数的编码，实际上是 8 位的值加上 4 位的 rotate。
https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/#play-with-it

ARM 指令集总设计：http://cs107e.github.io/readings/armisa.pdf

ARM 汇编语言：https://www.csie.ntu.edu.tw/~cyy/courses/assembly/09fall/lectures/handouts/lec09_ARMisa.pdf

Mac Installation Guide: http://cs107e.github.io/guides/mac_toolchain/

Compiler Explorer: https://gcc.godbolt.org/

Assignment:

调整亮度，我们可以通过控制高电平时间和低电平时间比例来调整。

GPIO 输出的电压是不能变化的，要么 3.3V，要么 0V。

## Week 3

数码管模拟 http://www.uize.com/examples/seven-segment-display.html

## ARM Tips

- Disassemble object file: `arm-none-eabi-objdump -D input.o`.

- Disassemble binary file: `arm-none-eabi-objdump -b binary -D -marm input.bin`.
